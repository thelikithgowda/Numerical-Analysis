# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZD39MCRAxzCdhf_uzI7mxRrgxMMU5U-4
"""

import random
from sympy import isprime

def generate_prime(bits=512):
    """Generates a random prime number with the given number of bits."""
    while True:
        num = random.getrandbits(bits)
        if isprime(num):
            return num

def gcd(a, b):
    """Computes the Greatest Common Divisor (GCD) using the Euclidean algorithm."""
    while b:
        a, b = b, a % b
    return a

def mod_inverse(e, phi):
    """Computes the modular inverse of e modulo phi using Extended Euclidean Algorithm."""
    d, x1, x2, y1 = 0, 0, 1, 1
    temp_phi = phi
    while e > 0:
        temp1, temp2 = divmod(temp_phi, e)
        temp_phi, e = e, temp2
        x, y = x2 - temp1 * x1, d - temp1 * y1
        x2, x1, d, y1 = x1, x, y1, y
    return d + phi if d < 0 else d

def generate_keypair(bits=512):
    """Generates public and private key pairs."""
    p, q = generate_prime(bits), generate_prime(bits)
    n = p * q
    phi = (p - 1) * (q - 1)
    e = 65537  # Common choice for e
    while gcd(e, phi) != 1:
        e = random.randrange(2, phi)
    d = mod_inverse(e, phi)
    return ((e, n), (d, n))

def encrypt(message, public_key):
    """Encrypts a message using the public key."""
    e, n = public_key
    return [pow(ord(char), e, n) for char in message]

def decrypt(ciphertext, private_key):
    """Decrypts a ciphertext using the private key."""
    d, n = private_key
    return ''.join(chr(pow(char, d, n)) for char in ciphertext)

if __name__ == "__main__":
    print("Generating RSA Key Pair...")
    public_key, private_key = generate_keypair(bits=512)
    print(f"Public Key: {public_key}")
    print(f"Private Key: {private_key}")

    message = input("Enter the message to encrypt: ")
    print(f"Original Message: {message}")

    encrypted_message = encrypt(message, public_key)
    print(f"Encrypted: {encrypted_message}")

    decrypted_message = decrypt(encrypted_message, private_key)
    print(f"Decrypted: {decrypted_message}")

import random
from sympy import isprime

def generate_prime(bits=512):
    """Generates a random prime number with the given number of bits."""
    while True:
        num = random.getrandbits(bits)
        if isprime(num):
            return num

def gcd(a, b):
    """Computes the Greatest Common Divisor (GCD) using the Euclidean algorithm."""
    while b:
        a, b = b, a % b
    return a

def mod_inverse(e, phi):
    """Computes the modular inverse of e modulo phi using Extended Euclidean Algorithm."""
    d, x1, x2, y1 = 0, 0, 1, 1
    temp_phi = phi
    while e > 0:
        temp1, temp2 = divmod(temp_phi, e)
        temp_phi, e = e, temp2
        x, y = x2 - temp1 * x1, d - temp1 * y1
        x2, x1, d, y1 = x1, x, y1, y
    return d + phi if d < 0 else d

def generate_keypair(bits=512):
    """Generates public and private key pairs."""
    p, q = generate_prime(bits), generate_prime(bits)
    n = p * q
    phi = (p - 1) * (q - 1)
    e = 65537  # Common choice for e
    while gcd(e, phi) != 1:
        e = random.randrange(2, phi)
    d = mod_inverse(e, phi)
    return ((e, n), (d, n))

def encrypt(message, public_key):
    """Encrypts a message using the public key."""
    e, n = public_key
    return [pow(ord(char), e, n) for char in message]

def decrypt(ciphertext, private_key):
    """Decrypts a ciphertext using the private key."""
    d, n = private_key
    return ''.join(chr(pow(char, d, n)) for char in ciphertext)

if __name__ == "__main__":
    print("Generating RSA Key Pair...")
    public_key, private_key = generate_keypair(bits=512)
    print(f"Public Key: {public_key}")
    print(f"Private Key: {private_key}")

    choice = input("Do you want to (E)ncrypt or (D)ecrypt? ").strip().upper()

    if choice == 'E':
        message = input("Enter the message to encrypt: ")
        encrypted_message = encrypt(message, public_key)
        print(f"Encrypted: {encrypted_message}")

    elif choice == 'D':
        encrypted_input = input("Enter the encrypted message as a list of numbers (comma-separated): ")
        ciphertext = [int(x) for x in encrypted_input.split(',')]
        decrypted_message = decrypt(ciphertext, private_key)
        print(f"Decrypted: {decrypted_message}")

    else:
        print("Invalid choice. Please enter 'E' for encryption or 'D' for decryption.")

import random
from sympy import isprime
import binascii

def generate_prime(bits=512):
    """Generates a random prime number with the given number of bits."""
    while True:
        num = random.getrandbits(bits)
        if isprime(num):
            return num

def gcd(a, b):
    """Computes the Greatest Common Divisor (GCD) using the Euclidean algorithm."""
    while b:
        a, b = b, a % b
    return a

def mod_inverse(e, phi):
    """Computes the modular inverse of e modulo phi using Extended Euclidean Algorithm."""
    d, x1, x2, y1 = 0, 0, 1, 1
    temp_phi = phi
    while e > 0:
        temp1, temp2 = divmod(temp_phi, e)
        temp_phi, e = e, temp2
        x, y = x2 - temp1 * x1, d - temp1 * y1
        x2, x1, d, y1 = x1, x, y1, y
    return d + phi if d < 0 else d

def generate_keypair(bits=512):
    """Generates public and private key pairs."""
    p, q = generate_prime(bits), generate_prime(bits)
    n = p * q
    phi = (p - 1) * (q - 1)
    e = 65537  # Common choice for e
    while gcd(e, phi) != 1:
        e = random.randrange(2, phi)
    d = mod_inverse(e, phi)
    return ((e, n), (d, n))

def encrypt(message, public_key):
    """Encrypts a message using the public key."""
    e, n = public_key
    message_bytes = message.encode()
    message_int = int.from_bytes(message_bytes, 'big')
    encrypted_int = pow(message_int, e, n)
    return encrypted_int

def decrypt(ciphertext, private_key):
    """Decrypts a ciphertext using the private key."""
    d, n = private_key
    decrypted_int = pow(ciphertext, d, n)

    # Ensure correct byte size and decoding
    decrypted_bytes = decrypted_int.to_bytes((decrypted_int.bit_length() + 7) // 8, 'big')
    try:
        return decrypted_bytes.decode('utf-8')
    except UnicodeDecodeError:
        return "[Decryption Error: Unable to decode message]"

if __name__ == "__main__":
    print("Generating RSA Key Pair...")
    public_key, private_key = generate_keypair(bits=512)
    print(f"Public Key: {public_key}")
    print(f"Private Key: {private_key}")

    choice = input("Do you want to (E)ncrypt or (D)ecrypt? ").strip().upper()

    if choice == 'E':
        message = input("Enter the message to encrypt: ")
        encrypted_message = encrypt(message, public_key)
        print(f"Encrypted: {encrypted_message}")

    elif choice == 'D':
        encrypted_input = int(input("Enter the encrypted message as an integer: "))
        decrypted_message = decrypt(encrypted_input, private_key)
        print(f"Decrypted: {decrypted_message}")

    else:
        print("Invalid choice. Please enter 'E' for encryption or 'D' for decryption.")

import random

def is_prime(n, k=5):
    """Miller-Rabin Primality Test"""
    if n <= 1:
        return False
    if n in (2, 3):
        return True
    if n % 2 == 0:
        return False

    # Write n as d * 2^r + 1
    r, d = 0, n - 1
    while d % 2 == 0:
        r += 1
        d //= 2

    # Witness loop
    for _ in range(k):
        a = random.randint(2, n - 2)
        x = pow(a, d, n)
        if x in (1, n - 1):
            continue

        for _ in range(r - 1):
            x = pow(x, 2, n)
            if x == n - 1:
                break
        else:
            return False
    return True

if __name__ == "__main__":
    num = int(input("Enter a number to check for primality: "))
    if is_prime(num):
        print(f"{num} is a prime number.")
    else:
        print(f"{num} is not a prime number.")

def gcd(a, b):
    """Finds the Greatest Common Divisor (GCD) using the Euclidean algorithm."""
    while b:
        a, b = b, a % b
    return a

def lcm(a, b):
    """Finds the Least Common Multiple (LCM) using the formula: LCM(a, b) = (a * b) / GCD(a, b)."""
    return (a * b) // gcd(a, b)

def is_coprime(a, b):
    """Checks if two numbers are coprime (GCD = 1)."""
    return gcd(a, b) == 1

if __name__ == "__main__":
    num1 = int(input("Enter the first number: "))
    num2 = int(input("Enter the second number: "))

    result_gcd = gcd(num1, num2)
    result_lcm = lcm(num1, num2)
    coprime_status = "Yes" if is_coprime(num1, num2) else "No"

    print(f"\nResults:")
    print(f"GCD of {num1} and {num2}: {result_gcd}")
    print(f"LCM of {num1} and {num2}: {result_lcm}")
    print(f"Are {num1} and {num2} coprime? {coprime_status}")

def modular_exponentiation(base, exponent, modulus):
    """Computes (base^exponent) % modulus efficiently using the Fast Exponentiation method."""
    result = 1
    base = base % modulus  # Reduce base if greater than modulus

    while exponent > 0:
        if exponent % 2 == 1:  # If exponent is odd, multiply base with result
            result = (result * base) % modulus
        base = (base * base) % modulus  # Square the base
        exponent //= 2  # Reduce exponent by half

    return result

if __name__ == "__main__":
    base = int(input("Enter the base: "))
    exponent = int(input("Enter the exponent: "))
    modulus = int(input("Enter the modulus: "))

    result = modular_exponentiation(base, exponent, modulus)
    print(f"({base}^{exponent}) % {modulus} = {result}")

def extended_gcd(a, b):
    """Returns GCD of a and b, along with x and y such that ax + by = GCD(a, b)."""
    if a == 0:
        return b, 0, 1
    else:
        gcd, x1, y1 = extended_gcd(b % a, a)
        x = y1 - (b // a) * x1
        y = x1
        return gcd, x, y

def modular_inverse(a, m):
    """Finds the modular inverse of a under modulo m, if it exists."""
    gcd, x, _ = extended_gcd(a, m)
    if gcd != 1:
        return None  # Modular inverse doesn't exist if GCD is not 1
    else:
        return x % m  # Ensure result is in the range [0, m-1]

if __name__ == "__main__":
    a = int(input("Enter a number: "))
    m = int(input("Enter the modulus: "))

    inverse = modular_inverse(a, m)

    if inverse is None:
        print(f"No modular inverse exists for {a} under modulo {m}.")
    else:
        print(f"The modular inverse of {a} under modulo {m} is {inverse}.")

import random

def gcd(a, b):
    """Finds the Greatest Common Divisor (GCD) using the Euclidean algorithm."""
    while b:
        a, b = b, a % b
    return a

def lcm(a, b):
    """Finds the Least Common Multiple (LCM) using the formula: LCM(a, b) = (a * b) / GCD(a, b)."""
    return (a * b) // gcd(a, b)

def is_coprime(a, b):
    """Checks if two numbers are coprime (GCD = 1)."""
    return gcd(a, b) == 1

def modular_exponentiation(base, exponent, modulus):
    """Computes (base^exponent) % modulus efficiently using Fast Exponentiation."""
    result = 1
    base = base % modulus  # Reduce base if greater than modulus

    while exponent > 0:
        if exponent % 2 == 1:  # If exponent is odd, multiply base with result
            result = (result * base) % modulus
        base = (base * base) % modulus  # Square the base
        exponent //= 2  # Reduce exponent by half

    return result

def extended_gcd(a, b):
    """Returns GCD of a and b, along with x and y such that ax + by = GCD(a, b)."""
    if a == 0:
        return b, 0, 1
    else:
        gcd, x1, y1 = extended_gcd(b % a, a)
        x = y1 - (b // a) * x1
        y = x1
        return gcd, x, y

def modular_inverse(a, m):
    """Finds the modular inverse of a under modulo m, if it exists."""
    gcd, x, _ = extended_gcd(a, m)
    if gcd != 1:
        return None  # Modular inverse doesn't exist if GCD is not 1
    else:
        return x % m  # Ensure result is in the range [0, m-1]

def main():
    while True:
        print("\nChoose an operation:")
        print("1. GCD (Greatest Common Divisor)")
        print("2. LCM (Least Common Multiple)")
        print("3. Coprimality Check")
        print("4. Modular Exponentiation")
        print("5. Modular Inverse (Extended Euclidean Algorithm)")
        print("6. Exit")

        choice = input("Enter your choice (1-6): ").strip()

        if choice == '1':  # GCD Calculation
            num1 = int(input("Enter the first number: "))
            num2 = int(input("Enter the second number: "))
            result = gcd(num1, num2)
            print(f"GCD of {num1} and {num2} is {result}")

        elif choice == '2':  # LCM Calculation
            num1 = int(input("Enter the first number: "))
            num2 = int(input("Enter the second number: "))
            result = lcm(num1, num2)
            print(f"LCM of {num1} and {num2} is {result}")

        elif choice == '3':  # Coprimality Check
            num1 = int(input("Enter the first number: "))
            num2 = int(input("Enter the second number: "))
            result = is_coprime(num1, num2)
            print(f"{num1} and {num2} are {'coprime' if result else 'not coprime'}.")

        elif choice == '4':  # Modular Exponentiation
            base = int(input("Enter the base: "))
            exponent = int(input("Enter the exponent: "))
            modulus = int(input("Enter the modulus: "))
            result = modular_exponentiation(base, exponent, modulus)
            print(f"({base}^{exponent}) % {modulus} = {result}")

        elif choice == '5':  # Modular Inverse
            num = int(input("Enter the number: "))
            mod = int(input("Enter the modulus: "))
            result = modular_inverse(num, mod)
            if result is None:
                print(f"No modular inverse exists for {num} under modulo {mod}.")
            else:
                print(f"The modular inverse of {num} under modulo {mod} is {result}")

        elif choice == '6':  # Exit
            print("Exiting the program. Goodbye!")
            break

        else:
            print("Invalid choice. Please enter a number between 1 and 6.")

if __name__ == "__main__":
    main()
1

import math

# Function to evaluate f(x)
def f(x):
    return x**3 - 4*x - 9  # Example function (Modify as needed)

# 1️⃣ Bisection Method
def bisection(a, b, tol=1e-6, max_iter=100):
    if f(a) * f(b) >= 0:
        print("Bisection method fails. Choose different initial values.")
        return None

    for _ in range(max_iter):
        c = (a + b) / 2  # Midpoint
        if abs(f(c)) < tol:
            return c
        elif f(a) * f(c) < 0:
            b = c
        else:
            a = c
    return c

# 2️⃣ Newton-Raphson Method
def derivative_f(x):
    return 3*x**2 - 4  # Derivative of f(x)

def newton_raphson(x0, tol=1e-6, max_iter=100):
    for _ in range(max_iter):
        fx = f(x0)
        dfx = derivative_f(x0)
        if dfx == 0:
            print("Zero derivative. No solution found.")
            return None
        x1 = x0 - fx / dfx
        if abs(x1 - x0) < tol:
            return x1
        x0 = x1
    return x0

# 3️⃣ Secant Method (Root Finding)
def secant_method(x0, x1, tol=1e-6, max_iter=100):
    for _ in range(max_iter):
        if abs(f(x1)) < tol:
            return x1
        x_temp = x1 - f(x1) * (x1 - x0) / (f(x1) - f(x0))
        x0, x1 = x1, x_temp
    return x1

# 4️⃣ Trapezoidal Rule (Numerical Integration)
def trapezoidal_rule(a, b, n=100):
    h = (b - a) / n
    integral = (f(a) + f(b)) / 2
    for i in range(1, n):
        integral += f(a + i * h)
    return integral * h

# 5️⃣ Simpson’s Rule (Numerical Integration)
def simpsons_rule(a, b, n=100):
    if n % 2 == 1:
        n += 1  # Ensure even n
    h = (b - a) / n
    integral = f(a) + f(b)
    for i in range(1, n, 2):
        integral += 4 * f(a + i * h)
    for i in range(2, n - 1, 2):
        integral += 2 * f(a + i * h)
    return integral * h / 3

# 6️⃣ Gauss-Seidel Method (Solves Linear Equations)
def gauss_seidel(A, B, tol=1e-6, max_iter=100):
    n = len(B)
    X = [0] * n
    for _ in range(max_iter):
        X_new = X[:]
        for i in range(n):
            sum_ = sum(A[i][j] * X_new[j] for j in range(n) if j != i)
            X_new[i] = (B[i] - sum_) / A[i][i]
        if all(abs(X_new[i] - X[i]) < tol for i in range(n)):
            return X_new
        X = X_new
    return X

# 7️⃣ Euler’s Method (Solves Differential Equations)
def eulers_method(f_prime, x0, y0, h, n):
    results = [(x0, y0)]
    for _ in range(n):
        y0 += h * f_prime(x0, y0)
        x0 += h
        results.append((x0, y0))
    return results

# Example function for Euler's method: dy/dx = x + y
def example_derivative(x, y):
    return x + y

# Main menu
def main():
    while True:
        print("\nChoose an operation:")
        print("1. Bisection Method (Root Finding)")
        print("2. Newton-Raphson Method (Root Finding)")
        print("3. Secant Method (Root Finding)")
        print("4. Trapezoidal Rule (Numerical Integration)")
        print("5. Simpson’s Rule (Numerical Integration)")
        print("6. Gauss-Seidel Method (Solving Linear Equations)")
        print("7. Euler’s Method (Solving Differential Equations)")
        print("8. Exit")

        choice = input("Enter your choice (1-8): ").strip()

        if choice == '1':  # Bisection Method
            a = float(input("Enter lower bound: "))
            b = float(input("Enter upper bound: "))
            result = bisection(a, b)
            print(f"Root found: {result}")

        elif choice == '2':  # Newton-Raphson Method
            x0 = float(input("Enter initial guess: "))
            result = newton_raphson(x0)
            print(f"Root found: {result}")

        elif choice == '3':  # Secant Method
            x0 = float(input("Enter first guess: "))
            x1 = float(input("Enter second guess: "))
            result = secant_method(x0, x1)
            print(f"Root found: {result}")

        elif choice == '4':  # Trapezoidal Rule
            a = float(input("Enter lower limit: "))
            b = float(input("Enter upper limit: "))
            result = trapezoidal_rule(a, b)
            print(f"Approximate integral: {result}")

        elif choice == '5':  # Simpson's Rule
            a = float(input("Enter lower limit: "))
            b = float(input("Enter upper limit: "))
            result = simpsons_rule(a, b)
            print(f"Approximate integral: {result}")

        elif choice == '6':  # Gauss-Seidel Method
            n = int(input("Enter matrix size: "))
            A = []
            B = []
            for i in range(n):
                row = list(map(float, input(f"Enter row {i+1} of matrix A (space-separated): ").split()))
                A.append(row)
                B.append(float(input(f"Enter value {i+1} of matrix B: ")))
            result = gauss_seidel(A, B)
            print(f"Solution: {result}")

        elif choice == '7':  # Euler’s Method
            x0 = float(input("Enter initial x: "))
            y0 = float(input("Enter initial y: "))
            h = float(input("Enter step size h: "))
            n = int(input("Enter number of steps: "))
            result = eulers_method(example_derivative, x0, y0, h, n)
            print("Euler’s Method Results:")
            for x, y in result:
                print(f"x: {x:.4f}, y: {y:.4f}")

        elif choice == '8':  # Exit
            print("Exiting the program. Goodbye!")
            break

        else:
            print("Invalid choice. Please enter a number between 1 and 8.")

if __name__ == "__main__":
    main()



import math

# Function to evaluate f(x)
def f(x):
    return x**3 - 4*x - 9  # Example function (Modify as needed)

# 1️⃣ Bisection Method
def bisection(a, b, tol=1e-6, max_iter=100):
    if f(a) * f(b) >= 0:
        print("Bisection method fails. Choose different initial values.")
        return None

    for i in range(max_iter):
        c = (a + b) / 2  # Midpoint
        if abs(f(c)) < tol:  # Root found
            return c
        elif f(a) * f(c) < 0:
            b = c
        else:
            a = c
    return c

# 2️⃣ Newton-Raphson Method
def derivative_f(x):
    return 3*x**2 - 4  # Derivative of f(x)

def newton_raphson(x0, tol=1e-6, max_iter=100):
    for i in range(max_iter):
        fx = f(x0)
        dfx = derivative_f(x0)
        if dfx == 0:
            print("Zero derivative. No solution found.")
            return None
        x1 = x0 - fx / dfx
        if abs(x1 - x0) < tol:
            return x1
        x0 = x1
    return x0

# 3️⃣ Trapezoidal Rule (Numerical Integration)
def trapezoidal_rule(a, b, n=100):
    h = (b - a) / n
    integral = (f(a) + f(b)) / 2
    for i in range(1, n):
        integral += f(a + i * h)
    return integral * h

# 4️⃣ Simpson’s Rule (Numerical Integration)
def simpsons_rule(a, b, n=100):
    if n % 2 == 1:
        n += 1  # Ensure even n
    h = (b - a) / n
    integral = f(a) + f(b)
    for i in range(1, n, 2):
        integral += 4 * f(a + i * h)
    for i in range(2, n - 1, 2):
        integral += 2 * f(a + i * h)
    return integral * h / 3

# Main menu
def main():
    while True:
        print("\nChoose an operation:")
        print("1. Bisection Method (Root Finding)")
        print("2. Newton-Raphson Method (Root Finding)")
        print("3. Trapezoidal Rule (Numerical Integration)")
        print("4. Simpson’s Rule (Numerical Integration)")
        print("5. Exit")

        choice = input("Enter your choice (1-5): ").strip()

        if choice == '1':  # Bisection Method
            a = float(input("Enter lower bound: "))
            b = float(input("Enter upper bound: "))
            result = bisection(a, b)
            print(f"Root found: {result}")

        elif choice == '2':  # Newton-Raphson Method
            x0 = float(input("Enter initial guess: "))
            result = newton_raphson(x0)
            print(f"Root found: {result}")

        elif choice == '3':  # Trapezoidal Rule
            a = float(input("Enter lower limit: "))
            b = float(input("Enter upper limit: "))
            result = trapezoidal_rule(a, b)
            print(f"Approximate integral: {result}")

        elif choice == '4':  # Simpson's Rule
            a = float(input("Enter lower limit: "))
            b = float(input("Enter upper limit: "))
            result = simpsons_rule(a, b)
            print(f"Approximate integral: {result}")

        elif choice == '5':  # Exit
            print("Exiting the program. Goodbye!")
            break

        else:
            print("Invalid choice. Please enter a number between 1 and 5.")

if __name__ == "__main__":
    main()